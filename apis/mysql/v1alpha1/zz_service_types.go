/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ComponentsObservation struct {
	Component *string `json:"component,omitempty" tf:"component,omitempty"`

	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	KafkaAuthenticationMethod *string `json:"kafkaAuthenticationMethod,omitempty" tf:"kafka_authentication_method,omitempty"`

	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	Route *string `json:"route,omitempty" tf:"route,omitempty"`

	SSL *bool `json:"ssl,omitempty" tf:"ssl,omitempty"`

	Usage *string `json:"usage,omitempty" tf:"usage,omitempty"`
}

type ComponentsParameters struct {
}

type IPFilterObjectObservation struct {

	// Description for IP filter list entry.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// CIDR address block.
	Network *string `json:"network,omitempty" tf:"network,omitempty"`
}

type IPFilterObjectParameters struct {

	// Description for IP filter list entry.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// CIDR address block.
	// +kubebuilder:validation:Required
	Network *string `json:"network" tf:"network,omitempty"`
}

type MigrationObservation struct {

	// Database name for bootstrapping the initial connection.
	Dbname *string `json:"dbname,omitempty" tf:"dbname,omitempty"`

	// Hostname or IP address of the server where to migrate data from.
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// Comma-separated list of databases, which should be ignored during migration (supported by MySQL and PostgreSQL only at the moment).
	IgnoreDbs *string `json:"ignoreDbs,omitempty" tf:"ignore_dbs,omitempty"`

	// The migration method to be used (currently supported only by Redis, MySQL and PostgreSQL service types).
	Method *string `json:"method,omitempty" tf:"method,omitempty"`

	// Port number of the server where to migrate data from.
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// The server where to migrate data from is secured with SSL. The default value is `true`.
	SSL *bool `json:"ssl,omitempty" tf:"ssl,omitempty"`

	// User name for authentication with the server where to migrate data from.
	Username *string `json:"username,omitempty" tf:"username,omitempty"`
}

type MigrationParameters struct {

	// Database name for bootstrapping the initial connection.
	// +kubebuilder:validation:Optional
	Dbname *string `json:"dbname,omitempty" tf:"dbname,omitempty"`

	// Hostname or IP address of the server where to migrate data from.
	// +kubebuilder:validation:Required
	Host *string `json:"host" tf:"host,omitempty"`

	// Comma-separated list of databases, which should be ignored during migration (supported by MySQL and PostgreSQL only at the moment).
	// +kubebuilder:validation:Optional
	IgnoreDbs *string `json:"ignoreDbs,omitempty" tf:"ignore_dbs,omitempty"`

	// The migration method to be used (currently supported only by Redis, MySQL and PostgreSQL service types).
	// +kubebuilder:validation:Optional
	Method *string `json:"method,omitempty" tf:"method,omitempty"`

	// Password for authentication with the server where to migrate data from.
	// +kubebuilder:validation:Optional
	PasswordSecretRef *v1.SecretKeySelector `json:"passwordSecretRef,omitempty" tf:"-"`

	// Port number of the server where to migrate data from.
	// +kubebuilder:validation:Required
	Port *float64 `json:"port" tf:"port,omitempty"`

	// The server where to migrate data from is secured with SSL. The default value is `true`.
	// +kubebuilder:validation:Optional
	SSL *bool `json:"ssl,omitempty" tf:"ssl,omitempty"`

	// User name for authentication with the server where to migrate data from.
	// +kubebuilder:validation:Optional
	Username *string `json:"username,omitempty" tf:"username,omitempty"`
}

type MySQLObservation struct {
}

type MySQLParameters struct {
}

type MySQLUserConfigMySQLObservation struct {

	// The number of seconds that the mysqld server waits for a connect packet before responding with Bad handshake.
	ConnectTimeout *float64 `json:"connectTimeout,omitempty" tf:"connect_timeout,omitempty"`

	// Default server time zone as an offset from UTC (from -12:00 to +12:00), a time zone name, or 'SYSTEM' to use the MySQL server default.
	DefaultTimeZone *string `json:"defaultTimeZone,omitempty" tf:"default_time_zone,omitempty"`

	// The maximum permitted result length in bytes for the GROUP_CONCAT() function.
	GroupConcatMaxLen *float64 `json:"groupConcatMaxLen,omitempty" tf:"group_concat_max_len,omitempty"`

	// The time, in seconds, before cached statistics expire.
	InformationSchemaStatsExpiry *float64 `json:"informationSchemaStatsExpiry,omitempty" tf:"information_schema_stats_expiry,omitempty"`

	// Maximum size for the InnoDB change buffer, as a percentage of the total size of the buffer pool. Default is 25.
	InnodbChangeBufferMaxSize *float64 `json:"innodbChangeBufferMaxSize,omitempty" tf:"innodb_change_buffer_max_size,omitempty"`

	// Specifies whether flushing a page from the InnoDB buffer pool also flushes other dirty pages in the same extent (default is 1): 0 - dirty pages in the same extent are not flushed,  1 - flush contiguous dirty pages in the same extent,  2 - flush dirty pages in the same extent.
	InnodbFlushNeighbors *float64 `json:"innodbFlushNeighbors,omitempty" tf:"innodb_flush_neighbors,omitempty"`

	// Minimum length of words that are stored in an InnoDB FULLTEXT index. Changing this parameter will lead to a restart of the MySQL service.
	InnodbFtMinTokenSize *float64 `json:"innodbFtMinTokenSize,omitempty" tf:"innodb_ft_min_token_size,omitempty"`

	// This option is used to specify your own InnoDB FULLTEXT index stopword list for all InnoDB tables.
	InnodbFtServerStopwordTable *string `json:"innodbFtServerStopwordTable,omitempty" tf:"innodb_ft_server_stopword_table,omitempty"`

	// The length of time in seconds an InnoDB transaction waits for a row lock before giving up. Default is 120.
	InnodbLockWaitTimeout *float64 `json:"innodbLockWaitTimeout,omitempty" tf:"innodb_lock_wait_timeout,omitempty"`

	// The size in bytes of the buffer that InnoDB uses to write to the log files on disk.
	InnodbLogBufferSize *float64 `json:"innodbLogBufferSize,omitempty" tf:"innodb_log_buffer_size,omitempty"`

	// The upper limit in bytes on the size of the temporary log files used during online DDL operations for InnoDB tables.
	InnodbOnlineAlterLogMaxSize *float64 `json:"innodbOnlineAlterLogMaxSize,omitempty" tf:"innodb_online_alter_log_max_size,omitempty"`

	// When enabled, information about all deadlocks in InnoDB user transactions is recorded in the error log. Disabled by default.
	InnodbPrintAllDeadlocks *bool `json:"innodbPrintAllDeadlocks,omitempty" tf:"innodb_print_all_deadlocks,omitempty"`

	// The number of I/O threads for read operations in InnoDB. Default is 4. Changing this parameter will lead to a restart of the MySQL service.
	InnodbReadIoThreads *float64 `json:"innodbReadIoThreads,omitempty" tf:"innodb_read_io_threads,omitempty"`

	// When enabled a transaction timeout causes InnoDB to abort and roll back the entire transaction. Changing this parameter will lead to a restart of the MySQL service.
	InnodbRollbackOnTimeout *bool `json:"innodbRollbackOnTimeout,omitempty" tf:"innodb_rollback_on_timeout,omitempty"`

	// Defines the maximum number of threads permitted inside of InnoDB. Default is 0 (infinite concurrency - no limit).
	InnodbThreadConcurrency *float64 `json:"innodbThreadConcurrency,omitempty" tf:"innodb_thread_concurrency,omitempty"`

	// The number of I/O threads for write operations in InnoDB. Default is 4. Changing this parameter will lead to a restart of the MySQL service.
	InnodbWriteIoThreads *float64 `json:"innodbWriteIoThreads,omitempty" tf:"innodb_write_io_threads,omitempty"`

	// The number of seconds the server waits for activity on an interactive connection before closing it.
	InteractiveTimeout *float64 `json:"interactiveTimeout,omitempty" tf:"interactive_timeout,omitempty"`

	// The storage engine for in-memory internal temporary tables.
	InternalTmpMemStorageEngine *string `json:"internalTmpMemStorageEngine,omitempty" tf:"internal_tmp_mem_storage_engine,omitempty"`

	// The slow_query_logs work as SQL statements that take more than long_query_time seconds to execute. Default is 10s.
	LongQueryTime *float64 `json:"longQueryTime,omitempty" tf:"long_query_time,omitempty"`

	// Size of the largest message in bytes that can be received by the server. Default is 67108864 (64M).
	MaxAllowedPacket *float64 `json:"maxAllowedPacket,omitempty" tf:"max_allowed_packet,omitempty"`

	// Limits the size of internal in-memory tables. Also set tmp_table_size. Default is 16777216 (16M).
	MaxHeapTableSize *float64 `json:"maxHeapTableSize,omitempty" tf:"max_heap_table_size,omitempty"`

	// Start sizes of connection buffer and result buffer. Default is 16384 (16K). Changing this parameter will lead to a restart of the MySQL service.
	NetBufferLength *float64 `json:"netBufferLength,omitempty" tf:"net_buffer_length,omitempty"`

	// The number of seconds to wait for more data from a connection before aborting the read.
	NetReadTimeout *float64 `json:"netReadTimeout,omitempty" tf:"net_read_timeout,omitempty"`

	// The number of seconds to wait for a block to be written to a connection before aborting the write.
	NetWriteTimeout *float64 `json:"netWriteTimeout,omitempty" tf:"net_write_timeout,omitempty"`

	// Global SQL mode. Set to empty to use MySQL server defaults. When creating a new service and not setting this field Aiven default SQL mode (strict, SQL standard compliant) will be assigned.
	SQLMode *string `json:"sqlMode,omitempty" tf:"sql_mode,omitempty"`

	// Require primary key to be defined for new tables or old tables modified with ALTER TABLE and fail if missing. It is recommended to always have primary keys because various functionality may break if any large table is missing them.
	SQLRequirePrimaryKey *bool `json:"sqlRequirePrimaryKey,omitempty" tf:"sql_require_primary_key,omitempty"`

	// Slow query log enables capturing of slow queries. Setting slow_query_log to false also truncates the mysql.slow_log table. Default is off.
	SlowQueryLog *bool `json:"slowQueryLog,omitempty" tf:"slow_query_log,omitempty"`

	// Sort buffer size in bytes for ORDER BY optimization. Default is 262144 (256K).
	SortBufferSize *float64 `json:"sortBufferSize,omitempty" tf:"sort_buffer_size,omitempty"`

	// Limits the size of internal in-memory tables. Also set max_heap_table_size. Default is 16777216 (16M).
	TmpTableSize *float64 `json:"tmpTableSize,omitempty" tf:"tmp_table_size,omitempty"`

	// The number of seconds the server waits for activity on a noninteractive connection before closing it.
	WaitTimeout *float64 `json:"waitTimeout,omitempty" tf:"wait_timeout,omitempty"`
}

type MySQLUserConfigMySQLParameters struct {

	// The number of seconds that the mysqld server waits for a connect packet before responding with Bad handshake.
	// +kubebuilder:validation:Optional
	ConnectTimeout *float64 `json:"connectTimeout,omitempty" tf:"connect_timeout,omitempty"`

	// Default server time zone as an offset from UTC (from -12:00 to +12:00), a time zone name, or 'SYSTEM' to use the MySQL server default.
	// +kubebuilder:validation:Optional
	DefaultTimeZone *string `json:"defaultTimeZone,omitempty" tf:"default_time_zone,omitempty"`

	// The maximum permitted result length in bytes for the GROUP_CONCAT() function.
	// +kubebuilder:validation:Optional
	GroupConcatMaxLen *float64 `json:"groupConcatMaxLen,omitempty" tf:"group_concat_max_len,omitempty"`

	// The time, in seconds, before cached statistics expire.
	// +kubebuilder:validation:Optional
	InformationSchemaStatsExpiry *float64 `json:"informationSchemaStatsExpiry,omitempty" tf:"information_schema_stats_expiry,omitempty"`

	// Maximum size for the InnoDB change buffer, as a percentage of the total size of the buffer pool. Default is 25.
	// +kubebuilder:validation:Optional
	InnodbChangeBufferMaxSize *float64 `json:"innodbChangeBufferMaxSize,omitempty" tf:"innodb_change_buffer_max_size,omitempty"`

	// Specifies whether flushing a page from the InnoDB buffer pool also flushes other dirty pages in the same extent (default is 1): 0 - dirty pages in the same extent are not flushed,  1 - flush contiguous dirty pages in the same extent,  2 - flush dirty pages in the same extent.
	// +kubebuilder:validation:Optional
	InnodbFlushNeighbors *float64 `json:"innodbFlushNeighbors,omitempty" tf:"innodb_flush_neighbors,omitempty"`

	// Minimum length of words that are stored in an InnoDB FULLTEXT index. Changing this parameter will lead to a restart of the MySQL service.
	// +kubebuilder:validation:Optional
	InnodbFtMinTokenSize *float64 `json:"innodbFtMinTokenSize,omitempty" tf:"innodb_ft_min_token_size,omitempty"`

	// This option is used to specify your own InnoDB FULLTEXT index stopword list for all InnoDB tables.
	// +kubebuilder:validation:Optional
	InnodbFtServerStopwordTable *string `json:"innodbFtServerStopwordTable,omitempty" tf:"innodb_ft_server_stopword_table,omitempty"`

	// The length of time in seconds an InnoDB transaction waits for a row lock before giving up. Default is 120.
	// +kubebuilder:validation:Optional
	InnodbLockWaitTimeout *float64 `json:"innodbLockWaitTimeout,omitempty" tf:"innodb_lock_wait_timeout,omitempty"`

	// The size in bytes of the buffer that InnoDB uses to write to the log files on disk.
	// +kubebuilder:validation:Optional
	InnodbLogBufferSize *float64 `json:"innodbLogBufferSize,omitempty" tf:"innodb_log_buffer_size,omitempty"`

	// The upper limit in bytes on the size of the temporary log files used during online DDL operations for InnoDB tables.
	// +kubebuilder:validation:Optional
	InnodbOnlineAlterLogMaxSize *float64 `json:"innodbOnlineAlterLogMaxSize,omitempty" tf:"innodb_online_alter_log_max_size,omitempty"`

	// When enabled, information about all deadlocks in InnoDB user transactions is recorded in the error log. Disabled by default.
	// +kubebuilder:validation:Optional
	InnodbPrintAllDeadlocks *bool `json:"innodbPrintAllDeadlocks,omitempty" tf:"innodb_print_all_deadlocks,omitempty"`

	// The number of I/O threads for read operations in InnoDB. Default is 4. Changing this parameter will lead to a restart of the MySQL service.
	// +kubebuilder:validation:Optional
	InnodbReadIoThreads *float64 `json:"innodbReadIoThreads,omitempty" tf:"innodb_read_io_threads,omitempty"`

	// When enabled a transaction timeout causes InnoDB to abort and roll back the entire transaction. Changing this parameter will lead to a restart of the MySQL service.
	// +kubebuilder:validation:Optional
	InnodbRollbackOnTimeout *bool `json:"innodbRollbackOnTimeout,omitempty" tf:"innodb_rollback_on_timeout,omitempty"`

	// Defines the maximum number of threads permitted inside of InnoDB. Default is 0 (infinite concurrency - no limit).
	// +kubebuilder:validation:Optional
	InnodbThreadConcurrency *float64 `json:"innodbThreadConcurrency,omitempty" tf:"innodb_thread_concurrency,omitempty"`

	// The number of I/O threads for write operations in InnoDB. Default is 4. Changing this parameter will lead to a restart of the MySQL service.
	// +kubebuilder:validation:Optional
	InnodbWriteIoThreads *float64 `json:"innodbWriteIoThreads,omitempty" tf:"innodb_write_io_threads,omitempty"`

	// The number of seconds the server waits for activity on an interactive connection before closing it.
	// +kubebuilder:validation:Optional
	InteractiveTimeout *float64 `json:"interactiveTimeout,omitempty" tf:"interactive_timeout,omitempty"`

	// The storage engine for in-memory internal temporary tables.
	// +kubebuilder:validation:Optional
	InternalTmpMemStorageEngine *string `json:"internalTmpMemStorageEngine,omitempty" tf:"internal_tmp_mem_storage_engine,omitempty"`

	// The slow_query_logs work as SQL statements that take more than long_query_time seconds to execute. Default is 10s.
	// +kubebuilder:validation:Optional
	LongQueryTime *float64 `json:"longQueryTime,omitempty" tf:"long_query_time,omitempty"`

	// Size of the largest message in bytes that can be received by the server. Default is 67108864 (64M).
	// +kubebuilder:validation:Optional
	MaxAllowedPacket *float64 `json:"maxAllowedPacket,omitempty" tf:"max_allowed_packet,omitempty"`

	// Limits the size of internal in-memory tables. Also set tmp_table_size. Default is 16777216 (16M).
	// +kubebuilder:validation:Optional
	MaxHeapTableSize *float64 `json:"maxHeapTableSize,omitempty" tf:"max_heap_table_size,omitempty"`

	// Start sizes of connection buffer and result buffer. Default is 16384 (16K). Changing this parameter will lead to a restart of the MySQL service.
	// +kubebuilder:validation:Optional
	NetBufferLength *float64 `json:"netBufferLength,omitempty" tf:"net_buffer_length,omitempty"`

	// The number of seconds to wait for more data from a connection before aborting the read.
	// +kubebuilder:validation:Optional
	NetReadTimeout *float64 `json:"netReadTimeout,omitempty" tf:"net_read_timeout,omitempty"`

	// The number of seconds to wait for a block to be written to a connection before aborting the write.
	// +kubebuilder:validation:Optional
	NetWriteTimeout *float64 `json:"netWriteTimeout,omitempty" tf:"net_write_timeout,omitempty"`

	// Global SQL mode. Set to empty to use MySQL server defaults. When creating a new service and not setting this field Aiven default SQL mode (strict, SQL standard compliant) will be assigned.
	// +kubebuilder:validation:Optional
	SQLMode *string `json:"sqlMode,omitempty" tf:"sql_mode,omitempty"`

	// Require primary key to be defined for new tables or old tables modified with ALTER TABLE and fail if missing. It is recommended to always have primary keys because various functionality may break if any large table is missing them.
	// +kubebuilder:validation:Optional
	SQLRequirePrimaryKey *bool `json:"sqlRequirePrimaryKey,omitempty" tf:"sql_require_primary_key,omitempty"`

	// Slow query log enables capturing of slow queries. Setting slow_query_log to false also truncates the mysql.slow_log table. Default is off.
	// +kubebuilder:validation:Optional
	SlowQueryLog *bool `json:"slowQueryLog,omitempty" tf:"slow_query_log,omitempty"`

	// Sort buffer size in bytes for ORDER BY optimization. Default is 262144 (256K).
	// +kubebuilder:validation:Optional
	SortBufferSize *float64 `json:"sortBufferSize,omitempty" tf:"sort_buffer_size,omitempty"`

	// Limits the size of internal in-memory tables. Also set max_heap_table_size. Default is 16777216 (16M).
	// +kubebuilder:validation:Optional
	TmpTableSize *float64 `json:"tmpTableSize,omitempty" tf:"tmp_table_size,omitempty"`

	// The number of seconds the server waits for activity on a noninteractive connection before closing it.
	// +kubebuilder:validation:Optional
	WaitTimeout *float64 `json:"waitTimeout,omitempty" tf:"wait_timeout,omitempty"`
}

type MySQLUserConfigObservation struct {

	// Additional Cloud Regions for Backup Replication.
	AdditionalBackupRegions []*string `json:"additionalBackupRegions,omitempty" tf:"additional_backup_regions,omitempty"`

	// Custom username for admin user. This must be set only when a new service is being created.
	AdminUsername *string `json:"adminUsername,omitempty" tf:"admin_username,omitempty"`

	// The hour of day (in UTC) when backup for the service is started. New backup is only started if previous backup has already completed.
	BackupHour *float64 `json:"backupHour,omitempty" tf:"backup_hour,omitempty"`

	// The minute of an hour when backup for the service is started. New backup is only started if previous backup has already completed.
	BackupMinute *float64 `json:"backupMinute,omitempty" tf:"backup_minute,omitempty"`

	// The minimum amount of time in seconds to keep binlog entries before deletion. This may be extended for services that require binlog entries for longer than the default for example if using the MySQL Debezium Kafka connector.
	BinlogRetentionPeriod *float64 `json:"binlogRetentionPeriod,omitempty" tf:"binlog_retention_period,omitempty"`

	// Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
	IPFilter []*string `json:"ipFilter,omitempty" tf:"ip_filter,omitempty"`

	// Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
	IPFilterObject []IPFilterObjectObservation `json:"ipFilterObject,omitempty" tf:"ip_filter_object,omitempty"`

	// Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
	IPFilterString []*string `json:"ipFilterString,omitempty" tf:"ip_filter_string,omitempty"`

	// Migrate data from existing server.
	Migration []MigrationObservation `json:"migration,omitempty" tf:"migration,omitempty"`

	// mysql.conf configuration values.
	MySQL []MySQLUserConfigMySQLObservation `json:"mysql,omitempty" tf:"mysql,omitempty"`

	// MySQL major version.
	MySQLVersion *string `json:"mysqlVersion,omitempty" tf:"mysql_version,omitempty"`

	// Allow access to selected service ports from private networks.
	PrivateAccess []PrivateAccessObservation `json:"privateAccess,omitempty" tf:"private_access,omitempty"`

	// Allow access to selected service components through Privatelink.
	PrivatelinkAccess []PrivatelinkAccessObservation `json:"privatelinkAccess,omitempty" tf:"privatelink_access,omitempty"`

	// Name of another project to fork a service from. This has effect only when a new service is being created.
	ProjectToForkFrom *string `json:"projectToForkFrom,omitempty" tf:"project_to_fork_from,omitempty"`

	// Allow access to selected service ports from the public Internet.
	PublicAccess []PublicAccessObservation `json:"publicAccess,omitempty" tf:"public_access,omitempty"`

	// Recovery target time when forking a service. This has effect only when a new service is being created.
	RecoveryTargetTime *string `json:"recoveryTargetTime,omitempty" tf:"recovery_target_time,omitempty"`

	// Name of another service to fork from. This has effect only when a new service is being created.
	ServiceToForkFrom *string `json:"serviceToForkFrom,omitempty" tf:"service_to_fork_from,omitempty"`

	// Use static public IP addresses.
	StaticIps *bool `json:"staticIps,omitempty" tf:"static_ips,omitempty"`
}

type MySQLUserConfigParameters struct {

	// Additional Cloud Regions for Backup Replication.
	// +kubebuilder:validation:Optional
	AdditionalBackupRegions []*string `json:"additionalBackupRegions,omitempty" tf:"additional_backup_regions,omitempty"`

	// Custom password for admin user. Defaults to random string. This must be set only when a new service is being created.
	// +kubebuilder:validation:Optional
	AdminPasswordSecretRef *v1.SecretKeySelector `json:"adminPasswordSecretRef,omitempty" tf:"-"`

	// Custom username for admin user. This must be set only when a new service is being created.
	// +kubebuilder:validation:Optional
	AdminUsername *string `json:"adminUsername,omitempty" tf:"admin_username,omitempty"`

	// The hour of day (in UTC) when backup for the service is started. New backup is only started if previous backup has already completed.
	// +kubebuilder:validation:Optional
	BackupHour *float64 `json:"backupHour,omitempty" tf:"backup_hour,omitempty"`

	// The minute of an hour when backup for the service is started. New backup is only started if previous backup has already completed.
	// +kubebuilder:validation:Optional
	BackupMinute *float64 `json:"backupMinute,omitempty" tf:"backup_minute,omitempty"`

	// The minimum amount of time in seconds to keep binlog entries before deletion. This may be extended for services that require binlog entries for longer than the default for example if using the MySQL Debezium Kafka connector.
	// +kubebuilder:validation:Optional
	BinlogRetentionPeriod *float64 `json:"binlogRetentionPeriod,omitempty" tf:"binlog_retention_period,omitempty"`

	// Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
	// +kubebuilder:validation:Optional
	IPFilter []*string `json:"ipFilter,omitempty" tf:"ip_filter,omitempty"`

	// Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
	// +kubebuilder:validation:Optional
	IPFilterObject []IPFilterObjectParameters `json:"ipFilterObject,omitempty" tf:"ip_filter_object,omitempty"`

	// Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
	// +kubebuilder:validation:Optional
	IPFilterString []*string `json:"ipFilterString,omitempty" tf:"ip_filter_string,omitempty"`

	// Migrate data from existing server.
	// +kubebuilder:validation:Optional
	Migration []MigrationParameters `json:"migration,omitempty" tf:"migration,omitempty"`

	// mysql.conf configuration values.
	// +kubebuilder:validation:Optional
	MySQL []MySQLUserConfigMySQLParameters `json:"mysql,omitempty" tf:"mysql,omitempty"`

	// MySQL major version.
	// +kubebuilder:validation:Optional
	MySQLVersion *string `json:"mysqlVersion,omitempty" tf:"mysql_version,omitempty"`

	// Allow access to selected service ports from private networks.
	// +kubebuilder:validation:Optional
	PrivateAccess []PrivateAccessParameters `json:"privateAccess,omitempty" tf:"private_access,omitempty"`

	// Allow access to selected service components through Privatelink.
	// +kubebuilder:validation:Optional
	PrivatelinkAccess []PrivatelinkAccessParameters `json:"privatelinkAccess,omitempty" tf:"privatelink_access,omitempty"`

	// Name of another project to fork a service from. This has effect only when a new service is being created.
	// +kubebuilder:validation:Optional
	ProjectToForkFrom *string `json:"projectToForkFrom,omitempty" tf:"project_to_fork_from,omitempty"`

	// Allow access to selected service ports from the public Internet.
	// +kubebuilder:validation:Optional
	PublicAccess []PublicAccessParameters `json:"publicAccess,omitempty" tf:"public_access,omitempty"`

	// Recovery target time when forking a service. This has effect only when a new service is being created.
	// +kubebuilder:validation:Optional
	RecoveryTargetTime *string `json:"recoveryTargetTime,omitempty" tf:"recovery_target_time,omitempty"`

	// Name of another service to fork from. This has effect only when a new service is being created.
	// +kubebuilder:validation:Optional
	ServiceToForkFrom *string `json:"serviceToForkFrom,omitempty" tf:"service_to_fork_from,omitempty"`

	// Use static public IP addresses.
	// +kubebuilder:validation:Optional
	StaticIps *bool `json:"staticIps,omitempty" tf:"static_ips,omitempty"`
}

type PrivateAccessObservation struct {

	// Allow clients to connect to mysql with a DNS name that always resolves to the service's private IP addresses. Only available in certain network locations.
	MySQL *bool `json:"mysql,omitempty" tf:"mysql,omitempty"`

	// Allow clients to connect to mysqlx with a DNS name that always resolves to the service's private IP addresses. Only available in certain network locations.
	Mysqlx *bool `json:"mysqlx,omitempty" tf:"mysqlx,omitempty"`

	// Allow clients to connect to prometheus with a DNS name that always resolves to the service's private IP addresses. Only available in certain network locations.
	Prometheus *bool `json:"prometheus,omitempty" tf:"prometheus,omitempty"`
}

type PrivateAccessParameters struct {

	// Allow clients to connect to mysql with a DNS name that always resolves to the service's private IP addresses. Only available in certain network locations.
	// +kubebuilder:validation:Optional
	MySQL *bool `json:"mysql,omitempty" tf:"mysql,omitempty"`

	// Allow clients to connect to mysqlx with a DNS name that always resolves to the service's private IP addresses. Only available in certain network locations.
	// +kubebuilder:validation:Optional
	Mysqlx *bool `json:"mysqlx,omitempty" tf:"mysqlx,omitempty"`

	// Allow clients to connect to prometheus with a DNS name that always resolves to the service's private IP addresses. Only available in certain network locations.
	// +kubebuilder:validation:Optional
	Prometheus *bool `json:"prometheus,omitempty" tf:"prometheus,omitempty"`
}

type PrivatelinkAccessObservation struct {

	// Enable mysql.
	MySQL *bool `json:"mysql,omitempty" tf:"mysql,omitempty"`

	// Enable mysqlx.
	Mysqlx *bool `json:"mysqlx,omitempty" tf:"mysqlx,omitempty"`

	// Enable prometheus.
	Prometheus *bool `json:"prometheus,omitempty" tf:"prometheus,omitempty"`
}

type PrivatelinkAccessParameters struct {

	// Enable mysql.
	// +kubebuilder:validation:Optional
	MySQL *bool `json:"mysql,omitempty" tf:"mysql,omitempty"`

	// Enable mysqlx.
	// +kubebuilder:validation:Optional
	Mysqlx *bool `json:"mysqlx,omitempty" tf:"mysqlx,omitempty"`

	// Enable prometheus.
	// +kubebuilder:validation:Optional
	Prometheus *bool `json:"prometheus,omitempty" tf:"prometheus,omitempty"`
}

type PublicAccessObservation struct {

	// Allow clients to connect to mysql from the public internet for service nodes that are in a project VPC or another type of private network.
	MySQL *bool `json:"mysql,omitempty" tf:"mysql,omitempty"`

	// Allow clients to connect to mysqlx from the public internet for service nodes that are in a project VPC or another type of private network.
	Mysqlx *bool `json:"mysqlx,omitempty" tf:"mysqlx,omitempty"`

	// Allow clients to connect to prometheus from the public internet for service nodes that are in a project VPC or another type of private network.
	Prometheus *bool `json:"prometheus,omitempty" tf:"prometheus,omitempty"`
}

type PublicAccessParameters struct {

	// Allow clients to connect to mysql from the public internet for service nodes that are in a project VPC or another type of private network.
	// +kubebuilder:validation:Optional
	MySQL *bool `json:"mysql,omitempty" tf:"mysql,omitempty"`

	// Allow clients to connect to mysqlx from the public internet for service nodes that are in a project VPC or another type of private network.
	// +kubebuilder:validation:Optional
	Mysqlx *bool `json:"mysqlx,omitempty" tf:"mysqlx,omitempty"`

	// Allow clients to connect to prometheus from the public internet for service nodes that are in a project VPC or another type of private network.
	// +kubebuilder:validation:Optional
	Prometheus *bool `json:"prometheus,omitempty" tf:"prometheus,omitempty"`
}

type ServiceIntegrationsObservation struct {

	// Type of the service integration. The only supported value at the moment is `read_replica`
	IntegrationType *string `json:"integrationType,omitempty" tf:"integration_type,omitempty"`

	// Name of the source service
	SourceServiceName *string `json:"sourceServiceName,omitempty" tf:"source_service_name,omitempty"`
}

type ServiceIntegrationsParameters struct {

	// Type of the service integration. The only supported value at the moment is `read_replica`
	// +kubebuilder:validation:Required
	IntegrationType *string `json:"integrationType" tf:"integration_type,omitempty"`

	// Name of the source service
	// +kubebuilder:validation:Required
	SourceServiceName *string `json:"sourceServiceName" tf:"source_service_name,omitempty"`
}

type ServiceObservation struct {

	// Additional disk space. Possible values depend on the service type, the cloud provider and the project. Therefore, reducing will result in the service rebalancing.
	AdditionalDiskSpace *string `json:"additionalDiskSpace,omitempty" tf:"additional_disk_space,omitempty"`

	// Defines where the cloud provider and region where the service is hosted in. This can be changed freely after service is created. Changing the value will trigger a potentially lengthy migration process for the service. Format is cloud provider name (`aws`, `azure`, `do` `google`, `upcloud`, etc.), dash, and the cloud provider specific region name. These are documented on each Cloud provider's own support articles, like [here for Google](https://cloud.google.com/compute/docs/regions-zones/) and [here for AWS](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.RegionsAndAvailabilityZones.html).
	CloudName *string `json:"cloudName,omitempty" tf:"cloud_name,omitempty"`

	// Service component information objects
	Components []ComponentsObservation `json:"components,omitempty" tf:"components,omitempty"`

	// Service disk space. Possible values depend on the service type, the cloud provider and the project. Therefore, reducing will result in the service rebalancing.
	DiskSpace *string `json:"diskSpace,omitempty" tf:"disk_space,omitempty"`

	// The maximum disk space of the service, possible values depend on the service type, the cloud provider and the project.
	DiskSpaceCap *string `json:"diskSpaceCap,omitempty" tf:"disk_space_cap,omitempty"`

	// The default disk space of the service, possible values depend on the service type, the cloud provider and the project. Its also the minimum value for `disk_space`
	DiskSpaceDefault *string `json:"diskSpaceDefault,omitempty" tf:"disk_space_default,omitempty"`

	// The default disk space step of the service, possible values depend on the service type, the cloud provider and the project. `disk_space` needs to increment from `disk_space_default` by increments of this size.
	DiskSpaceStep *string `json:"diskSpaceStep,omitempty" tf:"disk_space_step,omitempty"`

	// Disk space that service is currently using
	DiskSpaceUsed *string `json:"diskSpaceUsed,omitempty" tf:"disk_space_used,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Day of week when maintenance operations should be performed. One monday, tuesday, wednesday, etc.
	MaintenanceWindowDow *string `json:"maintenanceWindowDow,omitempty" tf:"maintenance_window_dow,omitempty"`

	// Time of day when maintenance operations should be performed. UTC time in HH:mm:ss format.
	MaintenanceWindowTime *string `json:"maintenanceWindowTime,omitempty" tf:"maintenance_window_time,omitempty"`

	// MySQL specific server provided values
	MySQL []MySQLObservation `json:"mysql,omitempty" tf:"mysql,omitempty"`

	// Mysql user configurable settings
	MySQLUserConfig []MySQLUserConfigObservation `json:"mysqlUserConfig,omitempty" tf:"mysql_user_config,omitempty"`

	// Defines what kind of computing resources are allocated for the service. It can be changed after creation, though there are some restrictions when going to a smaller plan such as the new plan must have sufficient amount of disk space to store all current data and switching to a plan with fewer nodes might not be supported. The basic plan names are `hobbyist`, `startup-x`, `business-x` and `premium-x` where `x` is (roughly) the amount of memory on each node (also other attributes like number of CPUs and amount of disk space varies but naming is based on memory). The available options can be seem from the [Aiven pricing page](https://aiven.io/pricing).
	Plan *string `json:"plan,omitempty" tf:"plan,omitempty"`

	// Identifies the project this resource belongs to. To set up proper dependencies please refer to this variable as a reference. This property cannot be changed, doing so forces recreation of the resource.
	Project *string `json:"project,omitempty" tf:"project,omitempty"`

	// Specifies the VPC the service should run in. If the value is not set the service is not run inside a VPC. When set, the value should be given as a reference to set up dependencies correctly and the VPC must be in the same cloud and region as the service itself. Project can be freely moved to and from VPC after creation but doing so triggers migration to new servers so the operation can take significant amount of time to complete if the service has a lot of data.
	ProjectVPCID *string `json:"projectVpcId,omitempty" tf:"project_vpc_id,omitempty"`

	// The hostname of the service.
	ServiceHost *string `json:"serviceHost,omitempty" tf:"service_host,omitempty"`

	// Service integrations to specify when creating a service. Not applied after initial service creation
	ServiceIntegrations []ServiceIntegrationsObservation `json:"serviceIntegrations,omitempty" tf:"service_integrations,omitempty"`

	// The port of the service
	ServicePort *float64 `json:"servicePort,omitempty" tf:"service_port,omitempty"`

	// Aiven internal service type code
	ServiceType *string `json:"serviceType,omitempty" tf:"service_type,omitempty"`

	// Username used for connecting to the service, if applicable
	ServiceUsername *string `json:"serviceUsername,omitempty" tf:"service_username,omitempty"`

	// Service state. One of `POWEROFF`, `REBALANCING`, `REBUILDING` or `RUNNING`
	State *string `json:"state,omitempty" tf:"state,omitempty"`

	// Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
	StaticIps []*string `json:"staticIps,omitempty" tf:"static_ips,omitempty"`

	// Tags are key-value pairs that allow you to categorize services.
	Tag []TagObservation `json:"tag,omitempty" tf:"tag,omitempty"`

	// Prevents the service from being deleted. It is recommended to set this to `true` for all production services to prevent unintentional service deletion. This does not shield against deleting databases or topics but for services with backups much of the content can at least be restored from backup in case accidental deletion is done.
	TerminationProtection *bool `json:"terminationProtection,omitempty" tf:"termination_protection,omitempty"`
}

type ServiceParameters struct {

	// Additional disk space. Possible values depend on the service type, the cloud provider and the project. Therefore, reducing will result in the service rebalancing.
	// +kubebuilder:validation:Optional
	AdditionalDiskSpace *string `json:"additionalDiskSpace,omitempty" tf:"additional_disk_space,omitempty"`

	// Defines where the cloud provider and region where the service is hosted in. This can be changed freely after service is created. Changing the value will trigger a potentially lengthy migration process for the service. Format is cloud provider name (`aws`, `azure`, `do` `google`, `upcloud`, etc.), dash, and the cloud provider specific region name. These are documented on each Cloud provider's own support articles, like [here for Google](https://cloud.google.com/compute/docs/regions-zones/) and [here for AWS](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.RegionsAndAvailabilityZones.html).
	// +kubebuilder:validation:Optional
	CloudName *string `json:"cloudName,omitempty" tf:"cloud_name,omitempty"`

	// Service disk space. Possible values depend on the service type, the cloud provider and the project. Therefore, reducing will result in the service rebalancing.
	// +kubebuilder:validation:Optional
	DiskSpace *string `json:"diskSpace,omitempty" tf:"disk_space,omitempty"`

	// Day of week when maintenance operations should be performed. One monday, tuesday, wednesday, etc.
	// +kubebuilder:validation:Optional
	MaintenanceWindowDow *string `json:"maintenanceWindowDow,omitempty" tf:"maintenance_window_dow,omitempty"`

	// Time of day when maintenance operations should be performed. UTC time in HH:mm:ss format.
	// +kubebuilder:validation:Optional
	MaintenanceWindowTime *string `json:"maintenanceWindowTime,omitempty" tf:"maintenance_window_time,omitempty"`

	// Mysql user configurable settings
	// +kubebuilder:validation:Optional
	MySQLUserConfig []MySQLUserConfigParameters `json:"mysqlUserConfig,omitempty" tf:"mysql_user_config,omitempty"`

	// Defines what kind of computing resources are allocated for the service. It can be changed after creation, though there are some restrictions when going to a smaller plan such as the new plan must have sufficient amount of disk space to store all current data and switching to a plan with fewer nodes might not be supported. The basic plan names are `hobbyist`, `startup-x`, `business-x` and `premium-x` where `x` is (roughly) the amount of memory on each node (also other attributes like number of CPUs and amount of disk space varies but naming is based on memory). The available options can be seem from the [Aiven pricing page](https://aiven.io/pricing).
	// +kubebuilder:validation:Optional
	Plan *string `json:"plan,omitempty" tf:"plan,omitempty"`

	// Identifies the project this resource belongs to. To set up proper dependencies please refer to this variable as a reference. This property cannot be changed, doing so forces recreation of the resource.
	// +kubebuilder:validation:Required
	Project *string `json:"project" tf:"project,omitempty"`

	// Specifies the VPC the service should run in. If the value is not set the service is not run inside a VPC. When set, the value should be given as a reference to set up dependencies correctly and the VPC must be in the same cloud and region as the service itself. Project can be freely moved to and from VPC after creation but doing so triggers migration to new servers so the operation can take significant amount of time to complete if the service has a lot of data.
	// +kubebuilder:validation:Optional
	ProjectVPCID *string `json:"projectVpcId,omitempty" tf:"project_vpc_id,omitempty"`

	// Service integrations to specify when creating a service. Not applied after initial service creation
	// +kubebuilder:validation:Optional
	ServiceIntegrations []ServiceIntegrationsParameters `json:"serviceIntegrations,omitempty" tf:"service_integrations,omitempty"`

	// Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
	// +kubebuilder:validation:Optional
	StaticIps []*string `json:"staticIps,omitempty" tf:"static_ips,omitempty"`

	// Tags are key-value pairs that allow you to categorize services.
	// +kubebuilder:validation:Optional
	Tag []TagParameters `json:"tag,omitempty" tf:"tag,omitempty"`

	// Prevents the service from being deleted. It is recommended to set this to `true` for all production services to prevent unintentional service deletion. This does not shield against deleting databases or topics but for services with backups much of the content can at least be restored from backup in case accidental deletion is done.
	// +kubebuilder:validation:Optional
	TerminationProtection *bool `json:"terminationProtection,omitempty" tf:"termination_protection,omitempty"`
}

type TagObservation struct {

	// Service tag key
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// Service tag value
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type TagParameters struct {

	// Service tag key
	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// Service tag value
	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

// ServiceSpec defines the desired state of Service
type ServiceSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ServiceParameters `json:"forProvider"`
}

// ServiceStatus defines the observed state of Service.
type ServiceStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ServiceObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Service is the Schema for the Services API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,aiven}
type Service struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.plan)",message="plan is a required parameter"
	Spec   ServiceSpec   `json:"spec"`
	Status ServiceStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ServiceList contains a list of Services
type ServiceList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Service `json:"items"`
}

// Repository type metadata.
var (
	Service_Kind             = "Service"
	Service_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Service_Kind}.String()
	Service_KindAPIVersion   = Service_Kind + "." + CRDGroupVersion.String()
	Service_GroupVersionKind = CRDGroupVersion.WithKind(Service_Kind)
)

func init() {
	SchemeBuilder.Register(&Service{}, &ServiceList{})
}
